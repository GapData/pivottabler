---
title: "02. Data Groups"
author: "Chris Bailiss"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{02. Data Groups}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Data Group Terminology

Data groups form the column headers and row headers in a pivot table.  Typically, the distinct values of a variable form a set of headings (i.e. a set of data groups).  Consider the following pivot table:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

In this pivot table, there are three sets of data groups:

* The first row of column headings are the train category data groups - "Express Passenger" and "Ordinary Passenger".
* The second row of column headings are the power type data groups - "DMU", "EMU", "HST", etc.
* The row headings are the train operating company data groups - "Arriva Trains Wales", "CrossCountry", etc.

The data groups form a hierarchy.  A data group can have child data groups.  In the pivot table above, there are three column data groups at the first level, "Express Passenger", "Ordinary Passenger" and "Total".  The "Express Passenger" group has four child data groups for the power types "DMU", "EMU", "HST" and "Total".  The "Ordinary Passenger" data group has three child groups and the "Total" data group has one child group (a blank group).  The second level of the column data groups is thus formed of (4+3+1=) eight data groups.   

## Adding data groups to a pivot table

There are a few different ways to add data groups to a pivot table.

* Adding data groups based on the data
* Adding data groups explicitly
* Adding data groups that combine values
* More complex data group layouts

### Adding data groups based on the data

The easiest way to add data groups to a pivot table is to simply generate data groups based on the distinct values that exist for a particular variable (i.e. in a particular column in a data frame).  This is the method used in the pivot table above.  

#### Considering parent data groups

By default, when adding additional levels to a pivot table after the first level (i.e. for level 2, 3, etc.), the filter criteria coming from parent data groups is considered.  For example, in the pivot table above, there are "Express Passenger" trains with a power type of "HST", but no "Ordinary Passenger" trains with a power type of "HST".  So while a "HST" data group exists under "Express Passenger", no"HST" data group exists underneath "Ordinary Passenger".

#### Ignoring parent data groups

Sometimes, a more uniform layout is preferred, i.e. in the above example, we would like "HST" to be present underneath "Ordinary Passenger" as well.  This can be accomplished by setting the argment `leafLevelPermutations` to `FALSE`.

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType", leafLevelPermutations=FALSE)
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

### Adding data groups explicitly

It is also possible to add data values explicitly, by passing a **list** of values as the `explicitListOfValues` argument.  When an explicit list of values is specified, the pivot table does not sort the values.  For example, if we wished to ignore the "HST" power type completely:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType", fromData=FALSE, explicitListOfValues=list("DMU", "EMU"))
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

#### Visual Totals

In the above example, some of the totals now do not appear to reconcile, e.g. "CrossCountry DMU" (22400) + "CrossCountry EMU" (0) does not equal "CrossCountry Total" (23141).  The difference is the "CrossCountry HST" (741) data group that has been omitted.   This may or may not be desirable, depending on how the pivot table is introduced, the title that is used, etc.

If it is desirable for the totals to reconcile, then visual totals can be enabled using the `visualTotals` argument:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType", fromData=FALSE, explicitListOfValues=list("DMU", "EMU"), visualTotals=TRUE)
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

### Adding data groups that combine values

By specifying values explicitly, it is also possible to combine multiple values into one data group.  For example, if the primary focus of an analysis is the two train operating companies operating the most trains ("London Midland" and "CrossCountry"), then "Arrival Trains Wales" and "Virgin" can be combined:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC", fromData=FALSE, explicitListOfValues=list(
    "London Midland", "CrossCountry", c("Arriva Trains Wales", "Virgin Trains")))
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

Should an alternative caption be preferred for the combined group, it can be specified by setting the name of the list element.  Following the example above, they could simply be labelled as "Other":

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC", fromData=FALSE, explicitListOfValues=list(
  "London Midland", "CrossCountry", "Other"=c("Arriva Trains Wales", "Virgin Trains")))
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

### More complex layouts of data groups

Adding data groups one-at-a-time for complete fine-grained control is also possible.  This is more involved and is described separately in the [Custom Layouts](customlayouts.html) vignette.

## Sorting data groups

Data groups can be sorted, both by the caption and by the result of a calculation.

By default, data groups are sorted into ascending order based on the caption displayed by the data group.  The caption is the text seen in the header cell, which is typically one of the distinct values from a column in a data frame.  E.g.:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

In the above example the train operating companies are sorted into ascending order alphabetically (**A**rriva, **C**rossCountry, **L**ondon, **V**irgin).  Similarly for the train category (**E**xpress, **O**rdinary) and power type (**D**MU, **E**MU **H**ST).  The totals appear in a fixed position, irrespective of the data group sorting.


The data groups can be sorted into descending order using `dataSortOrder` argument, e.g. to reverse the order of the train operating companies:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC", dataSortOrder="desc")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$renderPivot()
```

The data groups can also be sorted based on the result of a calculation using the `sortColumnDataGroups` or `sortRowGroups` methods, e.g. to sort the train operating companies into descending order by the total number of trains:

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC", dataSortOrder="desc")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$sortRowDataGroups(levelNumber=1, orderBy="calculation", sortOrder="desc")
pt$renderPivot()
```

The pivot is sorted using the totals for each data group.  In the pivot table above, the London Midland train operating company is in first place with 48,887 trains.  CrossCountry is in second place with 23,205 trains, etc.

Since the pivot table above only contains one calculation, it was not necessary to specify the name of the calculation when sorting the row groups.  If a pivot table contains more than one calculation, and there is a wish to sort by a calculation other than the first calculation that was defined, then the calculation can be specified by using the `calculationName` argument when calling either `sortColumnDataGroups` or `sortRowGroups`.

When sorting the headings at the second, third, etc level, the sort does not break the structure coming from the parent data groups, i.e. a separate sort is performed within each parent group, e.g.

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$sortColumnDataGroups(levelNumber=2, orderBy="calculation", sortOrder="desc")
pt$renderPivot()
```

In the example above, one sort was carried out for the power type groups under "Express Passenger" ("DMU" in first place with 33,387 trains, "EMU" second with 15,500 trains, etc.) and a separate sort was carried out for the power type groups under "Ordinary Passenger" ("EMU" first with 28,553 trains, "DMU" second with 6,564 trains, etc.).

The `sortColumnDataGroups` or `sortRowGroups` can also be used to reset the sort order back to an alphabetic order based on the captions of the groups, e.g.

```{r, warning=FALSE}
library(pivottabler)
pt <- PivotTable$new()
pt$addData(bhmtrains)
pt$addLeafColumnDataGroups("TrainCategory")
pt$addLeafColumnDataGroups("PowerType")
pt$addLeafRowDataGroups("TOC")
pt$defineCalculation(calculationName="TotalTrains", summariseExpression="n()")
pt$sortColumnDataGroups(levelNumber=2, orderBy="calculation", sortOrder="desc")
# the following line resets the sort order back, i.e. removes the sort applied in the line above
pt$sortColumnDataGroups(levelNumber=2, orderBy="caption", sortOrder="asc")
pt$renderPivot()
```

This can be useful when building a pivot table interactively, to quickly reset the sort order without needing to rebuild the entire pivot table. 

## Further Reading

The full set of vignettes is:

1. [Introduction](introduction.html)
2. [Data Groups](datagroups.html)
3. [Calculations](calculations.html)
4. [Formatting and Styling](formattingandstyling.html)
5. [Cell Context](cellcontext.html)
6. [Custom Layouts](customlayouts.html)
7. [Retrieving Data](retrievingdata.html)
8. [Manipulating Individual Cells](cellmanipulation.html) 
	
